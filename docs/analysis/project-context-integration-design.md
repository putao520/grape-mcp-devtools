# Grape MCP DevTools é¡¹ç›®ä¸Šä¸‹æ–‡é›†æˆè®¾è®¡

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°äº† **Grape MCP DevTools** å¦‚ä½•é€šè¿‡ GitHub API é›†æˆè·å–é¡¹ç›®ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä¸º AI ç¼–ç¨‹åŠ©æ‰‹æä¾›å‡†ç¡®çš„é¡¹ç›®èƒŒæ™¯å’Œå¼€å‘ç¯å¢ƒä¿¡æ¯ã€‚æˆ‘ä»¬ä¸“æ³¨äºç®€æ´å®ç”¨çš„è®¾è®¡ï¼Œé¿å…è¿‡åº¦å¤æ‚çš„æ¶æ„ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

### æ ¸å¿ƒä»·å€¼
1. **é¡¹ç›®ä¿¡æ¯è·å–**ï¼šä» GitHub è·å–é¡¹ç›®åŸºæœ¬ä¿¡æ¯ã€æŠ€æœ¯æ ˆå’Œå¼€å‘çŠ¶æ€
2. **ä»»åŠ¡ä¸Šä¸‹æ–‡æä¾›**ï¼šè·å–å½“å‰çš„ Issuesã€Pull Requests å’Œ Milestones
3. **æŠ€æœ¯èƒŒæ™¯åˆ†æ**ï¼šåˆ†æé¡¹ç›®çš„ä¸»è¦æŠ€æœ¯æ ˆå’Œå¼€å‘å·¥å…·
4. **ç®€æ´å®ç”¨åŸåˆ™**ï¼šé¿å…å¤æ‚çš„ AI åˆ†æï¼Œä¸“æ³¨äºæ•°æ®è·å–å’Œæ ¼å¼åŒ–

### éç›®æ ‡
- ä¸è¿›è¡Œå¤æ‚çš„ AI åˆ†æå’Œæ¨ç†
- ä¸æ„å»ºæ™ºèƒ½ä»£ç†ç³»ç»Ÿ
- ä¸æä¾›ç›´æ¥çš„ç¼–ç¨‹å»ºè®®
- ä¸è¿›è¡Œæ·±åº¦çš„ä»£ç åˆ†æ

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### æ•´ä½“è®¾è®¡åŸåˆ™
- **ç¬¬ä¸‰æ–¹ä¼˜å…ˆ**ï¼šä½¿ç”¨ GitHub API å’Œæˆç†Ÿçš„ HTTP åº“
- **ç®€æ´æ¶æ„**ï¼šé¿å…å¤æ‚çš„å¤šå±‚æŠ½è±¡
- **Windows å‹å¥½**ï¼šç¡®ä¿åœ¨ Windows ç¯å¢ƒä¸‹æ­£å¸¸å·¥ä½œ
- **å¯æµ‹è¯•æ€§**ï¼šæ‰€æœ‰åŠŸèƒ½éƒ½å¯ä»¥åœ¨çœŸå®ç¯å¢ƒä¸‹æµ‹è¯•

### æ¶æ„ç»„ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             GitHub API å±‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ REST API    â”‚ GraphQL API         â”‚   â”‚
â”‚  â”‚ è°ƒç”¨å™¨      â”‚ è°ƒç”¨å™¨              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          GitHub é›†æˆå·¥å…·å±‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ é¡¹ç›®ä¿¡æ¯    â”‚ ä»»åŠ¡ç®¡ç†            â”‚   â”‚
â”‚  â”‚ è·å–å™¨      â”‚ æ•°æ®æ”¶é›†å™¨           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ æŠ€æœ¯æ ˆ      â”‚ æ•°æ®æ ¼å¼åŒ–å™¨         â”‚   â”‚
â”‚  â”‚ åˆ†æå™¨      â”‚                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             MCP å·¥å…·æ¥å£                â”‚
â”‚         github_info å·¥å…·                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½å®ç°

### 1. GitHub é¡¹ç›®ä¿¡æ¯å·¥å…·

#### åŸºç¡€å®ç°
```rust
pub struct GitHubInfoTool {
    github_client: GitHubClient,
    cache: Arc<SimpleCache>,
    config: GitHubConfig,
}

impl MCPTool for GitHubInfoTool {
    fn name(&self) -> &str {
        "github_info"
    }
    
    fn description(&self) -> &str {
        "åœ¨éœ€è¦äº†è§£GitHubé¡¹ç›®èƒŒæ™¯æ—¶ï¼Œè·å–é¡¹ç›®åŸºæœ¬ä¿¡æ¯ã€å½“å‰ä»»åŠ¡çŠ¶æ€å’ŒæŠ€æœ¯æ ˆä¿¡æ¯ã€‚"
    }
    
    fn schema(&self) -> Value {
        json!({
            "type": "object",
            "required": ["repo"],
            "properties": {
                "repo": {
                    "type": "string",
                    "description": "GitHubä»“åº“è·¯å¾„ï¼ˆå¦‚ï¼šmicrosoft/vscodeï¼‰"
                },
                "type": {
                    "type": "string",
                    "description": "ä¿¡æ¯ç±»å‹",
                    "enum": ["basic", "tasks", "tech_stack", "recent_activity"],
                    "default": "basic"
                },
                "include_details": {
                    "type": "boolean",
                    "description": "æ˜¯å¦åŒ…å«è¯¦ç»†ä¿¡æ¯",
                    "default": false
                }
            }
        })
    }
    
    async fn execute(&self, params: Value) -> Result<Value> {
        let repo = params["repo"].as_str().unwrap_or("");
        let info_type = params["type"].as_str().unwrap_or("basic");
        let include_details = params["include_details"].as_bool().unwrap_or(false);
        
        // æ£€æŸ¥ç¼“å­˜
        let cache_key = format!("github_{}_{}", repo, info_type);
        if let Some(cached) = self.cache.get(&cache_key).await? {
            return Ok(cached);
        }
        
        // è·å–ä¿¡æ¯
        let result = match info_type {
            "basic" => self.get_basic_info(repo, include_details).await?,
            "tasks" => self.get_task_info(repo, include_details).await?,
            "tech_stack" => self.get_tech_stack_info(repo, include_details).await?,
            "recent_activity" => self.get_recent_activity(repo, include_details).await?,
            _ => return Err(anyhow::anyhow!("ä¸æ”¯æŒçš„ä¿¡æ¯ç±»å‹: {}", info_type)),
        };
        
        // æ ¼å¼åŒ–è¾“å‡º
        let output = json!({
            "content": [{
                "type": "text",
                "text": result
            }],
            "metadata": {
                "tool": "github_info",
                "repo": repo,
                "type": info_type,
                "timestamp": chrono::Utc::now().to_rfc3339()
            }
        });
        
        // ç¼“å­˜ç»“æœ
        self.cache.set(&cache_key, &output).await?;
        
        Ok(output)
    }
}
```

### 2. å…·ä½“åŠŸèƒ½å®ç°

#### 2.1 åŸºæœ¬é¡¹ç›®ä¿¡æ¯è·å–
```rust
impl GitHubInfoTool {
    async fn get_basic_info(&self, repo: &str, include_details: bool) -> Result<String> {
        let repo_info = self.github_client.get_repository(repo).await?;
        
        let mut info = format!(
            "## {} é¡¹ç›®ä¿¡æ¯\n\n",
            repo_info.name
        );
        
        info.push_str(&format!("**æè¿°**: {}\n", repo_info.description.unwrap_or("æ— æè¿°".to_string())));
        info.push_str(&format!("**ä¸»è¦è¯­è¨€**: {}\n", repo_info.language.unwrap_or("æœªçŸ¥".to_string())));
        info.push_str(&format!("**Stars**: {} | **Forks**: {}\n", repo_info.stargazers_count, repo_info.forks_count));
        info.push_str(&format!("**æœ€åæ›´æ–°**: {}\n", repo_info.updated_at));
        
        if include_details {
            // è·å–é¢å¤–çš„è¯¦ç»†ä¿¡æ¯
            let languages = self.github_client.get_languages(repo).await?;
            info.push_str("\n**æŠ€æœ¯æ ˆåˆ†å¸ƒ**:\n");
            for (lang, bytes) in languages {
                let percentage = (bytes as f64 / languages.values().sum::<u64>() as f64) * 100.0;
                info.push_str(&format!("- {}: {:.1}%\n", lang, percentage));
            }
            
            let topics = repo_info.topics.unwrap_or_default();
            if !topics.is_empty() {
                info.push_str(&format!("\n**æ ‡ç­¾**: {}\n", topics.join(", ")));
            }
        }
        
        Ok(info)
    }
    
    async fn get_task_info(&self, repo: &str, include_details: bool) -> Result<String> {
        let issues = self.github_client.get_open_issues(repo, 10).await?;
        let prs = self.github_client.get_open_pull_requests(repo, 10).await?;
        
        let mut info = format!("## {} å½“å‰ä»»åŠ¡çŠ¶æ€\n\n", repo);
        
        info.push_str(&format!("**å¼€æ”¾Issues**: {}\n", issues.len()));
        info.push_str(&format!("**å¼€æ”¾Pull Requests**: {}\n\n", prs.len()));
        
        if include_details && !issues.is_empty() {
            info.push_str("**æœ€è¿‘çš„Issues**:\n");
            for issue in issues.iter().take(5) {
                info.push_str(&format!(
                    "- [#{}] {} ({})\n",
                    issue.number,
                    issue.title,
                    issue.labels.iter().map(|l| &l.name).collect::<Vec<_>>().join(", ")
                ));
            }
        }
        
        if include_details && !prs.is_empty() {
            info.push_str("\n**æœ€è¿‘çš„Pull Requests**:\n");
            for pr in prs.iter().take(5) {
                info.push_str(&format!(
                    "- [#{}] {} (by {})\n",
                    pr.number,
                    pr.title,
                    pr.user.login
                ));
            }
        }
        
        Ok(info)
    }
    
    async fn get_tech_stack_info(&self, repo: &str, include_details: bool) -> Result<String> {
        // è·å–è¯­è¨€ç»Ÿè®¡
        let languages = self.github_client.get_languages(repo).await?;
        
        // åˆ†æé…ç½®æ–‡ä»¶
        let config_files = self.analyze_config_files(repo).await?;
        
        let mut info = format!("## {} æŠ€æœ¯æ ˆåˆ†æ\n\n", repo);
        
        info.push_str("**ä¸»è¦ç¼–ç¨‹è¯­è¨€**:\n");
        let total_bytes: u64 = languages.values().sum();
        for (lang, bytes) in languages.iter().take(5) {
            let percentage = (*bytes as f64 / total_bytes as f64) * 100.0;
            info.push_str(&format!("- {}: {:.1}%\n", lang, percentage));
        }
        
        if include_details {
            info.push_str("\n**å¼€å‘å·¥å…·å’Œæ¡†æ¶**:\n");
            for config in config_files {
                info.push_str(&format!("- {}: {}\n", config.file_type, config.detected_tools.join(", ")));
            }
        }
        
        Ok(info)
    }
    
    async fn get_recent_activity(&self, repo: &str, include_details: bool) -> Result<String> {
        let commits = self.github_client.get_recent_commits(repo, 10).await?;
        let releases = self.github_client.get_recent_releases(repo, 5).await?;
        
        let mut info = format!("## {} æœ€è¿‘æ´»åŠ¨\n\n", repo);
        
        if !commits.is_empty() {
            info.push_str("**æœ€è¿‘æäº¤**:\n");
            for commit in commits.iter().take(if include_details { 10 } else { 5 }) {
                info.push_str(&format!(
                    "- {} by {} ({})\n",
                    commit.commit.message.lines().next().unwrap_or(""),
                    commit.commit.author.name,
                    commit.commit.author.date
                ));
            }
        }
        
        if include_details && !releases.is_empty() {
            info.push_str("\n**æœ€è¿‘å‘å¸ƒ**:\n");
            for release in releases {
                info.push_str(&format!(
                    "- {} ({}) - {}\n",
                    release.tag_name,
                    release.published_at.unwrap_or("æœªçŸ¥æ—¥æœŸ".to_string()),
                    release.name.unwrap_or("æ— æ ‡é¢˜".to_string())
                ));
            }
        }
        
        Ok(info)
    }
}
```

### 3. GitHub API å®¢æˆ·ç«¯

#### ç®€åŒ–çš„ HTTP å®¢æˆ·ç«¯
```rust
pub struct GitHubClient {
    http_client: reqwest::Client,
    base_url: String,
    token: Option<String>,
}

impl GitHubClient {
    pub fn new(token: Option<String>) -> Self {
        let mut headers = reqwest::header::HeaderMap::new();
        headers.insert(
            reqwest::header::USER_AGENT,
            "grape-mcp-devtools/1.0.0".parse().unwrap()
        );
        
        if let Some(ref token) = token {
            headers.insert(
                reqwest::header::AUTHORIZATION,
                format!("Bearer {}", token).parse().unwrap()
            );
        }
        
        let http_client = reqwest::Client::builder()
            .default_headers(headers)
            .timeout(Duration::from_secs(30))
            .build()
            .expect("Failed to create HTTP client");
        
        Self {
            http_client,
            base_url: "https://api.github.com".to_string(),
            token,
        }
    }
    
    pub async fn get_repository(&self, repo: &str) -> Result<Repository> {
        let url = format!("{}/repos/{}", self.base_url, repo);
        let response = self.http_client.get(&url).send().await?;
        
        if !response.status().is_success() {
            return Err(anyhow::anyhow!("GitHub APIé”™è¯¯: {}", response.status()));
        }
        
        let repo_info: Repository = response.json().await?;
        Ok(repo_info)
    }
    
    pub async fn get_open_issues(&self, repo: &str, limit: usize) -> Result<Vec<Issue>> {
        let url = format!("{}/repos/{}/issues", self.base_url, repo);
        let response = self.http_client
            .get(&url)
            .query(&[("state", "open"), ("per_page", &limit.to_string())])
            .send()
            .await?;
        
        if !response.status().is_success() {
            return Err(anyhow::anyhow!("GitHub APIé”™è¯¯: {}", response.status()));
        }
        
        let issues: Vec<Issue> = response.json().await?;
        Ok(issues)
    }
    
    // å…¶ä»– API æ–¹æ³•...
}
```

## ğŸ“Š æ•°æ®ç»“æ„è®¾è®¡

### ç®€åŒ–çš„æ•°æ®æ¨¡å‹
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct Repository {
    pub name: String,
    pub full_name: String,
    pub description: Option<String>,
    pub language: Option<String>,
    pub stargazers_count: u32,
    pub forks_count: u32,
    pub updated_at: String,
    pub topics: Option<Vec<String>>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Issue {
    pub number: u32,
    pub title: String,
    pub state: String,
    pub labels: Vec<Label>,
    pub user: User,
    pub created_at: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PullRequest {
    pub number: u32,
    pub title: String,
    pub state: String,
    pub user: User,
    pub created_at: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ConfigFileAnalysis {
    pub file_type: String,
    pub detected_tools: Vec<String>,
    pub framework_info: Option<String>,
}
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### çœŸå®ç¯å¢ƒæµ‹è¯•
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_github_basic_info() {
        let tool = GitHubInfoTool::new(None); // æ— éœ€tokençš„å…¬å¼€ä»“åº“æµ‹è¯•
        
        let params = json!({
            "repo": "microsoft/vscode",
            "type": "basic"
        });
        
        let result = tool.execute(params).await;
        assert!(result.is_ok());
        
        let output = result.unwrap();
        assert!(output["content"][0]["text"].as_str().unwrap().contains("vscode"));
    }
    
    #[tokio::test]
    async fn test_github_task_info() {
        let tool = GitHubInfoTool::new(None);
        
        let params = json!({
            "repo": "rust-lang/rust",
            "type": "tasks",
            "include_details": true
        });
        
        let result = tool.execute(params).await;
        assert!(result.is_ok());
    }
}
```

## âš™ï¸ é…ç½®ç®¡ç†

### ç¯å¢ƒå˜é‡é…ç½®
```env
# GitHub APIé…ç½®
GITHUB_TOKEN=your_token_here
GITHUB_API_TIMEOUT_SECONDS=30

# ç¼“å­˜é…ç½®
GITHUB_CACHE_TTL_HOURS=6
GITHUB_MAX_REQUESTS_PER_HOUR=4000
```

### é…ç½®æ–‡ä»¶
```toml
[github]
api_url = "https://api.github.com"
timeout_seconds = 30
max_requests_per_hour = 4000
cache_ttl_hours = 6

[github.rate_limit]
enable_respect = true
fallback_delay_seconds = 60
max_retries = 3
```

## ğŸš€ éƒ¨ç½²å’Œä½¿ç”¨

### Windows ç¯å¢ƒä¼˜åŒ–
- ä½¿ç”¨æ ‡å‡†çš„ Windows è·¯å¾„å¤„ç†
- æ”¯æŒ PowerShell ç¯å¢ƒå˜é‡
- ç¡®ä¿ HTTPS è¯ä¹¦éªŒè¯æ­£å¸¸å·¥ä½œ

### æ€§èƒ½è€ƒè™‘
- åˆç†çš„ç¼“å­˜ç­–ç•¥ï¼ˆ6å°æ—¶TTLï¼‰
- éµå®ˆ GitHub API é™åˆ¶
- å¼‚æ­¥å¹¶å‘å¤„ç†
- é”™è¯¯é‡è¯•æœºåˆ¶

## ğŸ“ˆ ç›‘æ§å’Œç»´æŠ¤

### å…³é”®æŒ‡æ ‡
- GitHub API è°ƒç”¨æˆåŠŸç‡
- å“åº”æ—¶é—´ç»Ÿè®¡
- ç¼“å­˜å‘½ä¸­ç‡
- é”™è¯¯ç±»å‹åˆ†å¸ƒ

### é”™è¯¯å¤„ç†
- ç½‘ç»œè¶…æ—¶è‡ªåŠ¨é‡è¯•
- API é™åˆ¶å‹å¥½é™çº§
- è¯¦ç»†çš„é”™è¯¯æ—¥å¿—è®°å½•
- ç”¨æˆ·å‹å¥½çš„é”™è¯¯ä¿¡æ¯

---

*é¡¹ç›®ä¸Šä¸‹æ–‡é›†æˆè®¾è®¡ç‰ˆæœ¬ï¼šv3.0*  
*æœ€åæ›´æ–°ï¼š2025å¹´1æœˆ*  
*ç®€åŒ–è®¾è®¡ä¸“æ³¨å®ç”¨ä»·å€¼* 