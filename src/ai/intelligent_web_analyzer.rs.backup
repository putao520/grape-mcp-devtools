use anyhow::Result;
use serde_json::{json, Value};
use tracing::{info, debug, warn};
use std::collections::{HashMap, HashSet};
use url::Url;
use chrono::{DateTime, Utc};
use regex;

use super::ai_service::{AIService, AIRequest};

/// ä»»åŠ¡å¯¼å‘çš„æ™ºèƒ½ç½‘é¡µåˆ†æå™¨
/// ä¸“é—¨ä¸ºç‰¹å®šç›®æ ‡ï¼ˆå¦‚æŸä¸ªåº“çš„æ–‡æ¡£ã€APIå‚è€ƒç­‰ï¼‰è¿›è¡Œæ™ºèƒ½åˆ†æ
pub struct IntelligentWebAnalyzer {
    ai_service: AIService,
    analysis_cache: std::sync::Arc<tokio::sync::RwLock<HashMap<String, CachedAnalysis>>>,
}

/// çˆ¬è™«ä»»åŠ¡å®šä¹‰
#[derive(Debug, Clone)]
pub struct CrawlTask {
    /// ä»»åŠ¡ID
    pub task_id: String,
    /// ç›®æ ‡æè¿°ï¼ˆä¾‹å¦‚ï¼š"å¯»æ‰¾tokioåº“çš„å¼‚æ­¥ç¼–ç¨‹æ•™ç¨‹å’ŒAPIæ–‡æ¡£"ï¼‰
    pub target_description: String,
    /// èµ·å§‹URL
    pub start_url: String,
    /// ç›®æ ‡åº“/æŠ€æœ¯åç§°
    pub library_name: String,
    /// ç¼–ç¨‹è¯­è¨€
    pub programming_language: String,
    /// æœŸæœ›çš„å†…å®¹ç±»å‹
    pub expected_content_types: Vec<ContentType>,
    /// æœ€å¤§æ·±åº¦
    pub max_depth: u32,
    /// æœ€å¤§é¡µé¢æ•°
    pub max_pages: u32,
    /// ä»»åŠ¡åˆ›å»ºæ—¶é—´
    pub created_at: DateTime<Utc>,
}

/// å†…å®¹ç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum ContentType {
    Documentation,
    Tutorial,
    ApiReference,
    Examples,
    GettingStarted,
    Installation,
    Configuration,
    Troubleshooting,
    Changelog,
    Community,
}

/// ç½‘é¡µç›¸å…³æ€§åˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct PageRelevanceAnalysis {
    /// ç›¸å…³æ€§åˆ†æ•° (0.0-1.0)
    pub relevance_score: f32,
    /// æ˜¯å¦ä¸ä»»åŠ¡ç›®æ ‡ç›¸å…³
    pub is_relevant: bool,
    /// ç›¸å…³æ€§åŸå› 
    pub relevance_reasons: Vec<String>,
    /// æ£€æµ‹åˆ°çš„å†…å®¹ç±»å‹
    pub detected_content_types: Vec<ContentType>,
    /// é‡è¦æ€§çº§åˆ« (1-5)
    pub importance_level: u8,
    /// æ¨èçš„ä¸‹ä¸€æ­¥è¡ŒåŠ¨
    pub recommended_actions: Vec<RecommendedAction>,
}

/// æ¨èè¡ŒåŠ¨
#[derive(Debug, Clone)]
pub enum RecommendedAction {
    ExtractContent,
    FollowLinks,
    SkipPage,
    PrioritizeHighly,
    AnalyzeDeeper,
}

/// å†…å®¹åŒºåŸŸè¯†åˆ«ç»“æœ
#[derive(Debug, Clone)]
pub struct ContentRegionAnalysis {
    /// ä¸»è¦å†…å®¹åŒºåŸŸ
    pub main_content_regions: Vec<ContentRegion>,
    /// å¯¼èˆªåŒºåŸŸ
    pub navigation_regions: Vec<ContentRegion>,
    /// ä¾§è¾¹æ åŒºåŸŸ
    pub sidebar_regions: Vec<ContentRegion>,
    /// ç›¸å…³é“¾æ¥åŒºåŸŸ
    pub related_links_regions: Vec<ContentRegion>,
    /// ä»£ç ç¤ºä¾‹åŒºåŸŸ
    pub code_regions: Vec<ContentRegion>,
}

/// å†…å®¹åŒºåŸŸ
#[derive(Debug, Clone)]
pub struct ContentRegion {
    /// åŒºåŸŸç±»å‹
    pub region_type: RegionType,
    /// åŒºåŸŸå†…å®¹
    pub content: String,
    /// ç›¸å…³æ€§åˆ†æ•°
    pub relevance_score: f32,
    /// HTMLé€‰æ‹©å™¨è·¯å¾„
    pub selector_path: Option<String>,
    /// æå–çš„é“¾æ¥
    pub extracted_links: Vec<ExtractedLink>,
}

/// åŒºåŸŸç±»å‹
#[derive(Debug, Clone)]
pub enum RegionType {
    MainContent,
    Navigation,
    Sidebar,
    CodeExample,
    ApiDocumentation,
    Tutorial,
    RelatedLinks,
    TableOfContents,
}

/// æå–çš„é“¾æ¥
#[derive(Debug, Clone)]
pub struct ExtractedLink {
    /// é“¾æ¥URL
    pub url: String,
    /// é“¾æ¥æ–‡æœ¬
    pub text: String,
    /// é“¾æ¥ç±»å‹
    pub link_type: LinkType,
    /// ç›¸å…³æ€§åˆ†æ•°
    pub relevance_score: f32,
    /// ä¼˜å…ˆçº§ (1-5)
    pub priority: u8,
}

/// é“¾æ¥ç±»å‹
#[derive(Debug, Clone)]
pub enum LinkType {
    Documentation,
    Tutorial,
    ApiReference,
    Example,
    Download,
    ExternalReference,
    Navigation,
    Related,
}

/// ç¼“å­˜çš„åˆ†æç»“æœ
#[derive(Debug, Clone)]
struct CachedAnalysis {
    relevance_analysis: PageRelevanceAnalysis,
    content_regions: ContentRegionAnalysis,
    timestamp: DateTime<Utc>,
}

impl IntelligentWebAnalyzer {
    /// åˆ›å»ºæ–°çš„æ™ºèƒ½ç½‘é¡µåˆ†æå™¨
    pub async fn new(ai_service: AIService) -> Result<Self> {
        Ok(Self {
            ai_service,
            analysis_cache: std::sync::Arc::new(tokio::sync::RwLock::new(HashMap::new())),
        })
    }

    /// åˆ†æç½‘é¡µä¸ä»»åŠ¡çš„ç›¸å…³æ€§
    pub async fn analyze_page_relevance(&self, html_content: &str, url: &str, task: &CrawlTask) -> Result<PageRelevanceAnalysis> {
        info!("ğŸ” åˆ†æç½‘é¡µç›¸å…³æ€§: {} (ä»»åŠ¡: {})", url, task.target_description);

        // æ£€æŸ¥ç¼“å­˜
        let cache_key = format!("relevance:{}:{}", url, task.task_id);
        if let Some(cached) = self.get_cached_relevance(&cache_key).await {
            debug!("ğŸ¯ ä½¿ç”¨ç¼“å­˜çš„ç›¸å…³æ€§åˆ†æç»“æœ");
            return Ok(cached);
        }

        // æ„å»ºAIåˆ†æè¯·æ±‚
        let system_prompt = self.get_relevance_analysis_system_prompt();
        let user_message = self.get_relevance_analysis_user_prompt(html_content, url, task);

        let ai_request = AIRequest {
            model: None,
            system_prompt: Some(system_prompt),
            user_message,
            temperature: Some(0.2),
            max_tokens: Some(3000),
            stream: false,
        };

        let ai_response = self.ai_service.request(ai_request).await?;
        let analysis = self.parse_relevance_analysis_response(&ai_response.content, task).await?;

        // ç¼“å­˜ç»“æœ
        self.cache_relevance_analysis(&cache_key, &analysis).await;

        Ok(analysis)
    }

    /// è¯†åˆ«å’Œåˆ†æå†…å®¹åŒºåŸŸ
    pub async fn analyze_content_regions(&self, html_content: &str, url: &str, task: &CrawlTask) -> Result<ContentRegionAnalysis> {
        info!("ğŸ“‹ åˆ†æå†…å®¹åŒºåŸŸ: {} (ä»»åŠ¡: {})", url, task.target_description);

        // æ„å»ºAIåˆ†æè¯·æ±‚
        let system_prompt = self.get_content_region_system_prompt();
        let user_message = self.get_content_region_user_prompt(html_content, url, task);

        let ai_request = AIRequest {
            model: None,
            system_prompt: Some(system_prompt),
            user_message,
            temperature: Some(0.3),
            max_tokens: Some(4000),
            stream: false,
        };

        let ai_response = self.ai_service.request(ai_request).await?;
        let regions = self.parse_content_region_response(&ai_response.content, task).await?;

        Ok(regions)
    }

    /// æå–å’Œè¯„ä¼°ç›¸å…³é“¾æ¥
    pub async fn extract_relevant_links(&self, html_content: &str, current_url: &str, task: &CrawlTask) -> Result<Vec<ExtractedLink>> {
        info!("ğŸ”— æå–ç›¸å…³é“¾æ¥: {} (ä»»åŠ¡: {})", current_url, task.target_description);

        let system_prompt = self.get_link_extraction_system_prompt();
        let user_message = self.get_link_extraction_user_prompt(html_content, current_url, task);

        let ai_request = AIRequest {
            model: None,
            system_prompt: Some(system_prompt),
            user_message,
            temperature: Some(0.3),
            max_tokens: Some(3000),
            stream: false,
        };

        let ai_response = self.ai_service.request(ai_request).await?;
        let links = self.parse_link_extraction_response(&ai_response.content, current_url, task).await?;

        Ok(links)
    }

    /// ç»¼åˆåˆ†æé¡µé¢ï¼ˆç›¸å…³æ€§ + å†…å®¹åŒºåŸŸ + é“¾æ¥æå–ï¼‰
    pub async fn comprehensive_page_analysis(&self, html_content: &str, url: &str, task: &CrawlTask) -> Result<(PageRelevanceAnalysis, ContentRegionAnalysis, Vec<ExtractedLink>)> {
        info!("ğŸ¯ å¼€å§‹ç»¼åˆé¡µé¢åˆ†æ: {}", url);

        // å¹¶è¡Œæ‰§è¡Œä¸‰ä¸ªåˆ†æä»»åŠ¡
        let (relevance_result, regions_result, links_result) = tokio::try_join!(
            self.analyze_page_relevance(html_content, url, task),
            self.analyze_content_regions(html_content, url, task),
            self.extract_relevant_links(html_content, url, task)
        )?;

        info!("âœ… ç»¼åˆé¡µé¢åˆ†æå®Œæˆï¼Œç›¸å…³æ€§åˆ†æ•°: {:.2}", relevance_result.relevance_score);

        Ok((relevance_result, regions_result, links_result))
    }

    /// ç”Ÿæˆä»»åŠ¡ç›®æ ‡çš„å†…å®¹æ‘˜è¦
    pub async fn generate_task_focused_summary(&self, content_regions: &ContentRegionAnalysis, task: &CrawlTask) -> Result<String> {
        info!("ğŸ“ ç”Ÿæˆä»»åŠ¡å¯¼å‘çš„å†…å®¹æ‘˜è¦");

        // é€‰æ‹©æœ€ç›¸å…³çš„å†…å®¹åŒºåŸŸ
        let relevant_content: String = content_regions.main_content_regions
            .iter()
            .filter(|region| region.relevance_score > 0.7)
            .map(|region| region.content.clone())
            .collect::<Vec<_>>()
            .join("\n\n");

        let system_prompt = self.get_task_summary_system_prompt();
        let user_message = self.get_task_summary_user_prompt(&relevant_content, task);

        let ai_request = AIRequest {
            model: None,
            system_prompt: Some(system_prompt),
            user_message,
            temperature: Some(0.3),
            max_tokens: Some(2000),
            stream: false,
        };

        let ai_response = self.ai_service.request(ai_request).await?;
        Ok(ai_response.content)
    }

    /// è·å–ç›¸å…³æ€§åˆ†æç³»ç»Ÿæç¤ºè¯
    fn get_relevance_analysis_system_prompt(&self) -> String {
        r#"ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç½‘é¡µå†…å®¹ç›¸å…³æ€§åˆ†æä¸“å®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯åˆ†æç»™å®šç½‘é¡µæ˜¯å¦ä¸ç‰¹å®šçš„çˆ¬è™«ä»»åŠ¡ç›®æ ‡ç›¸å…³ã€‚

åˆ†æç»´åº¦ï¼š
1. å†…å®¹ç›¸å…³æ€§ - é¡µé¢å†…å®¹æ˜¯å¦ä¸ç›®æ ‡åº“/æŠ€æœ¯ç›¸å…³
2. å†…å®¹ç±»å‹ - è¯†åˆ«é¡µé¢çš„å†…å®¹ç±»å‹ï¼ˆæ–‡æ¡£ã€æ•™ç¨‹ã€APIç­‰ï¼‰
3. è´¨é‡è¯„ä¼° - è¯„ä¼°å†…å®¹çš„è´¨é‡å’Œå®Œæ•´æ€§
4. é‡è¦æ€§è¯„çº§ - åˆ¤æ–­é¡µé¢åœ¨æ•´ä¸ªä»»åŠ¡ä¸­çš„é‡è¦ç¨‹åº¦
5. è¡ŒåŠ¨å»ºè®® - æ¨èä¸‹ä¸€æ­¥åº”è¯¥é‡‡å–çš„è¡ŒåŠ¨

è¯·ä»¥JSONæ ¼å¼è¿”å›åˆ†æç»“æœï¼ŒåŒ…å«ï¼š
- relevance_score: ç›¸å…³æ€§åˆ†æ•°(0.0-1.0)
- is_relevant: æ˜¯å¦ç›¸å…³(true/false)
- relevance_reasons: ç›¸å…³æ€§åŸå› æ•°ç»„
- detected_content_types: æ£€æµ‹åˆ°çš„å†…å®¹ç±»å‹æ•°ç»„
- importance_level: é‡è¦æ€§çº§åˆ«(1-5)
- recommended_actions: æ¨èè¡ŒåŠ¨æ•°ç»„

ä¿æŒåˆ†æçš„ä¸“ä¸šæ€§å’Œå‡†ç¡®æ€§ã€‚"#.to_string()
    }

    /// è·å–ç›¸å…³æ€§åˆ†æç”¨æˆ·æç¤ºè¯
    fn get_relevance_analysis_user_prompt(&self, html_content: &str, url: &str, task: &CrawlTask) -> String {
        // é™åˆ¶HTMLå†…å®¹é•¿åº¦ä»¥é¿å…è¶…è¿‡tokené™åˆ¶
        let truncated_content = if html_content.len() > 6000 {
            format!("{}...", &html_content[..6000])
        } else {
            html_content.to_string()
        };

        format!(r#"è¯·åˆ†æä»¥ä¸‹ç½‘é¡µæ˜¯å¦ä¸çˆ¬è™«ä»»åŠ¡ç›¸å…³ï¼š

ä»»åŠ¡æè¿°ï¼š{}
ç›®æ ‡åº“ï¼š{}
ç¼–ç¨‹è¯­è¨€ï¼š{}
æœŸæœ›å†…å®¹ç±»å‹ï¼š{:?}

å½“å‰é¡µé¢URLï¼š{}
é¡µé¢å†…å®¹ï¼š
{}

è¯·åˆ†ææ­¤é¡µé¢ä¸ä»»åŠ¡ç›®æ ‡çš„ç›¸å…³æ€§ï¼Œå¹¶æä¾›è¯¦ç»†çš„åˆ†æç»“æœã€‚"#, 
            task.target_description,
            task.library_name,
            task.programming_language,
            task.expected_content_types,
            url,
            truncated_content
        )
    }

    /// è·å–å†…å®¹åŒºåŸŸåˆ†æç³»ç»Ÿæç¤ºè¯
    fn get_content_region_system_prompt(&self) -> String {
        r#"ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç½‘é¡µå†…å®¹åŒºåŸŸè¯†åˆ«ä¸“å®¶ã€‚ä½ éœ€è¦è¯†åˆ«å¹¶åˆ†æç½‘é¡µä¸­çš„ä¸åŒå†…å®¹åŒºåŸŸã€‚

è¯†åˆ«çš„åŒºåŸŸç±»å‹ï¼š
1. ä¸»è¦å†…å®¹åŒºåŸŸ - åŒ…å«æ ¸å¿ƒä¿¡æ¯çš„åŒºåŸŸ
2. å¯¼èˆªåŒºåŸŸ - ç½‘ç«™å¯¼èˆªå’Œèœå•
3. ä¾§è¾¹æ åŒºåŸŸ - ç›¸å…³é“¾æ¥å’Œè¾…åŠ©ä¿¡æ¯
4. ä»£ç ç¤ºä¾‹åŒºåŸŸ - ä»£ç å—å’Œç¤ºä¾‹
5. APIæ–‡æ¡£åŒºåŸŸ - APIå‚è€ƒå’Œæ–‡æ¡£
6. æ•™ç¨‹åŒºåŸŸ - æ•™ç¨‹å’ŒæŒ‡å—å†…å®¹
7. ç›¸å…³é“¾æ¥åŒºåŸŸ - ç›¸å…³èµ„æºé“¾æ¥

å¯¹æ¯ä¸ªåŒºåŸŸè¯·æä¾›ï¼š
- åŒºåŸŸç±»å‹
- å†…å®¹æ‘˜è¦
- ç›¸å…³æ€§åˆ†æ•°
- æå–çš„é‡è¦é“¾æ¥

è¯·ä»¥JSONæ ¼å¼è¿”å›ç»“æœã€‚"#.to_string()
    }

    /// è·å–å†…å®¹åŒºåŸŸåˆ†æç”¨æˆ·æç¤ºè¯
    fn get_content_region_user_prompt(&self, html_content: &str, url: &str, task: &CrawlTask) -> String {
        let truncated_content = if html_content.len() > 7000 {
            format!("{}...", &html_content[..7000])
        } else {
            html_content.to_string()
        };

        format!(r#"è¯·è¯†åˆ«å¹¶åˆ†æä»¥ä¸‹ç½‘é¡µçš„å†…å®¹åŒºåŸŸï¼š

ä»»åŠ¡ç›®æ ‡ï¼š{}
ç›®æ ‡åº“ï¼š{}

é¡µé¢URLï¼š{}
é¡µé¢å†…å®¹ï¼š
{}

è¯·è¯†åˆ«æ‰€æœ‰é‡è¦çš„å†…å®¹åŒºåŸŸï¼Œç‰¹åˆ«å…³æ³¨ä¸{}ç›¸å…³çš„å†…å®¹ã€‚"#,
            task.target_description,
            task.library_name,
            url,
            truncated_content,
            task.library_name
        )
    }

    /// è·å–é“¾æ¥æå–ç³»ç»Ÿæç¤ºè¯
    fn get_link_extraction_system_prompt(&self) -> String {
        r#"ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ç›¸å…³é“¾æ¥æå–ä¸“å®¶ã€‚ä½ çš„ä»»åŠ¡æ˜¯ä»ç½‘é¡µä¸­æå–ä¸ç‰¹å®šä»»åŠ¡ç›®æ ‡ç›¸å…³çš„é“¾æ¥ã€‚

æå–åŸåˆ™ï¼š
1. ä¼˜å…ˆæå–ä¸ç›®æ ‡åº“/æŠ€æœ¯ç›´æ¥ç›¸å…³çš„é“¾æ¥
2. è¯†åˆ«ä¸åŒç±»å‹çš„é“¾æ¥ï¼ˆæ–‡æ¡£ã€æ•™ç¨‹ã€APIã€ç¤ºä¾‹ç­‰ï¼‰
3. è¯„ä¼°æ¯ä¸ªé“¾æ¥çš„ç›¸å…³æ€§å’Œä¼˜å…ˆçº§
4. é¿å…æå–æ— å…³æˆ–ä½è´¨é‡çš„é“¾æ¥

å¯¹æ¯ä¸ªé“¾æ¥è¯·æä¾›ï¼š
- é“¾æ¥URLï¼ˆè½¬æ¢ä¸ºç»å¯¹URLï¼‰
- é“¾æ¥æ–‡æœ¬
- é“¾æ¥ç±»å‹
- ç›¸å…³æ€§åˆ†æ•°(0.0-1.0)
- ä¼˜å…ˆçº§(1-5)

è¯·ä»¥JSONæ ¼å¼è¿”å›é“¾æ¥æ•°ç»„ã€‚"#.to_string()
    }

    /// è·å–é“¾æ¥æå–ç”¨æˆ·æç¤ºè¯
    fn get_link_extraction_user_prompt(&self, html_content: &str, current_url: &str, task: &CrawlTask) -> String {
        let truncated_content = if html_content.len() > 6000 {
            format!("{}...", &html_content[..6000])
        } else {
            html_content.to_string()
        };

        format!(r#"è¯·ä»ä»¥ä¸‹ç½‘é¡µä¸­æå–ä¸ä»»åŠ¡ç›¸å…³çš„é“¾æ¥ï¼š

ä»»åŠ¡æè¿°ï¼š{}
ç›®æ ‡åº“ï¼š{}
å½“å‰é¡µé¢ï¼š{}

é¡µé¢å†…å®¹ï¼š
{}

è¯·æå–æ‰€æœ‰ä¸{}ç›¸å…³çš„æœ‰ä»·å€¼é“¾æ¥ï¼Œå¹¶è¯„ä¼°å…¶ç›¸å…³æ€§å’Œä¼˜å…ˆçº§ã€‚"#,
            task.target_description,
            task.library_name,
            current_url,
            truncated_content,
            task.library_name
        )
    }

    /// è·å–ä»»åŠ¡æ‘˜è¦ç³»ç»Ÿæç¤ºè¯
    fn get_task_summary_system_prompt(&self) -> String {
        r#"ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å†…å®¹æ‘˜è¦ä¸“å®¶ã€‚ä½ éœ€è¦æ ¹æ®ç‰¹å®šçš„çˆ¬è™«ä»»åŠ¡ç›®æ ‡ï¼Œç”Ÿæˆç²¾å‡†çš„å†…å®¹æ‘˜è¦ã€‚

æ‘˜è¦è¦æ±‚ï¼š
1. çªå‡ºä¸ä»»åŠ¡ç›®æ ‡æœ€ç›¸å…³çš„ä¿¡æ¯
2. ä¿æŒæŠ€æœ¯å‡†ç¡®æ€§
3. ç»“æ„æ¸…æ™°ï¼Œæ˜“äºç†è§£
4. åŒ…å«å…³é”®çš„æŠ€æœ¯ç»†èŠ‚
5. æ§åˆ¶é•¿åº¦ï¼Œçªå‡ºé‡ç‚¹

è¯·ç”Ÿæˆä¸€ä¸ªä¸“ä¸šçš„ã€é’ˆå¯¹ä»»åŠ¡ç›®æ ‡çš„å†…å®¹æ‘˜è¦ã€‚"#.to_string()
    }

    /// è·å–ä»»åŠ¡æ‘˜è¦ç”¨æˆ·æç¤ºè¯
    fn get_task_summary_user_prompt(&self, content: &str, task: &CrawlTask) -> String {
        format!(r#"è¯·ä¸ºä»¥ä¸‹å†…å®¹ç”Ÿæˆé’ˆå¯¹ä»»åŠ¡ç›®æ ‡çš„æ‘˜è¦ï¼š

ä»»åŠ¡ç›®æ ‡ï¼š{}
ç›®æ ‡åº“ï¼š{}
ç¼–ç¨‹è¯­è¨€ï¼š{}

å†…å®¹ï¼š
{}

è¯·ç”Ÿæˆä¸€ä¸ªä¸“ä¸šçš„æ‘˜è¦ï¼Œçªå‡ºä¸{}ç›¸å…³çš„å…³é”®ä¿¡æ¯ã€‚"#,
            task.target_description,
            task.library_name,
            task.programming_language,
            content,
            task.library_name
        )
    }

    /// è§£æç›¸å…³æ€§åˆ†æå“åº”
    async fn parse_relevance_analysis_response(&self, response: &str, task: &CrawlTask) -> Result<PageRelevanceAnalysis> {
        if let Ok(json_value) = serde_json::from_str::<Value>(response) {
            let relevance_score = json_value.get("relevance_score")
                .and_then(|v| v.as_f64())
                .unwrap_or(0.3) as f32;

            let is_relevant = json_value.get("is_relevant")
                .and_then(|v| v.as_bool())
                .unwrap_or(false);

            let relevance_reasons = json_value.get("relevance_reasons")
                .and_then(|v| v.as_array())
                .map(|arr| arr.iter().filter_map(|v| v.as_str().map(|s| s.to_string())).collect())
                .unwrap_or_default();

            let detected_content_types = json_value.get("detected_content_types")
                .and_then(|v| v.as_array())
                .map(|arr| arr.iter().filter_map(|v| self.parse_content_type(v.as_str().unwrap_or(""))).collect())
                .unwrap_or_default();

            let importance_level = json_value.get("importance_level")
                .and_then(|v| v.as_u64())
                .unwrap_or(3) as u8;

            let recommended_actions = json_value.get("recommended_actions")
                .and_then(|v| v.as_array())
                .map(|arr| arr.iter().filter_map(|v| self.parse_recommended_action(v.as_str().unwrap_or(""))).collect())
                .unwrap_or_default();

            Ok(PageRelevanceAnalysis {
                relevance_score,
                is_relevant,
                relevance_reasons,
                detected_content_types,
                importance_level,
                recommended_actions,
            })
        } else {
            // åŸºäºæ–‡æœ¬å†…å®¹çš„è§£æ
            let is_relevant = response.to_lowercase().contains(&task.library_name.to_lowercase());
            Ok(PageRelevanceAnalysis {
                relevance_score: if is_relevant { 0.7 } else { 0.3 },
                is_relevant,
                relevance_reasons: vec!["åŸºäºå…³é”®è¯åŒ¹é…åˆ†æ".to_string()],
                detected_content_types: vec![ContentType::Documentation],
                importance_level: 3,
                recommended_actions: vec![if is_relevant { RecommendedAction::ExtractContent } else { RecommendedAction::SkipPage }],
            })
        }
    }

    /// è§£æå†…å®¹åŒºåŸŸå“åº”
    async fn parse_content_region_response(&self, response: &str, task: &CrawlTask) -> Result<ContentRegionAnalysis> {
        // å®Œæ•´çš„å†…å®¹åŒºåŸŸè§£æå®ç°
        if let Ok(json_value) = serde_json::from_str::<Value>(response) {
            let mut main_content_regions = Vec::new();
            let mut navigation_regions = Vec::new();
            let mut sidebar_regions = Vec::new();
            let mut related_links_regions = Vec::new();
            let mut code_regions = Vec::new();

            // è§£æä¸»è¦å†…å®¹åŒºåŸŸ
            if let Some(main_regions) = json_value.get("main_content_regions").and_then(|v| v.as_array()) {
                for region_data in main_regions {
                    if let Some(region) = self.parse_content_region(region_data, RegionType::MainContent) {
                        main_content_regions.push(region);
                    }
                }
            }

            // è§£æå¯¼èˆªåŒºåŸŸ
            if let Some(nav_regions) = json_value.get("navigation_regions").and_then(|v| v.as_array()) {
                for region_data in nav_regions {
                    if let Some(region) = self.parse_content_region(region_data, RegionType::Navigation) {
                        navigation_regions.push(region);
                    }
                }
            }

            // è§£æä¾§è¾¹æ åŒºåŸŸ
            if let Some(sidebar_regions_data) = json_value.get("sidebar_regions").and_then(|v| v.as_array()) {
                for region_data in sidebar_regions_data {
                    if let Some(region) = self.parse_content_region(region_data, RegionType::Sidebar) {
                        sidebar_regions.push(region);
                    }
                }
            }

            // è§£æç›¸å…³é“¾æ¥åŒºåŸŸ
            if let Some(links_regions) = json_value.get("related_links_regions").and_then(|v| v.as_array()) {
                for region_data in links_regions {
                    if let Some(region) = self.parse_content_region(region_data, RegionType::RelatedLinks) {
                        related_links_regions.push(region);
                    }
                }
            }

            // è§£æä»£ç åŒºåŸŸ
            if let Some(code_regions_data) = json_value.get("code_regions").and_then(|v| v.as_array()) {
                for region_data in code_regions_data {
                    if let Some(region) = self.parse_content_region(region_data, RegionType::CodeExample) {
                        code_regions.push(region);
                    }
                }
            }

            Ok(ContentRegionAnalysis {
                main_content_regions,
                navigation_regions,
                sidebar_regions,
                related_links_regions,
                code_regions,
            })
        } else {
            // åŸºäºæ–‡æœ¬å†…å®¹çš„æ™ºèƒ½è§£æ
            self.parse_content_regions_from_text(response, task).await
        }
    }

    /// è§£æé“¾æ¥æå–å“åº”
    async fn parse_link_extraction_response(&self, response: &str, current_url: &str, task: &CrawlTask) -> Result<Vec<ExtractedLink>> {
        // å®Œæ•´çš„é“¾æ¥æå–è§£æå®ç°
        if let Ok(json_value) = serde_json::from_str::<Value>(response) {
            let mut extracted_links = Vec::new();

            if let Some(links_array) = json_value.get("extracted_links").and_then(|v| v.as_array()) {
                for link_data in links_array {
                    if let Some(link) = self.parse_extracted_link(link_data, current_url, task) {
                        extracted_links.push(link);
                    }
                }
            }

            // æŒ‰ç›¸å…³æ€§åˆ†æ•°æ’åº
            extracted_links.sort_by(|a, b| b.relevance_score.partial_cmp(&a.relevance_score).unwrap_or(std::cmp::Ordering::Equal));

            Ok(extracted_links)
        } else {
            // åŸºäºæ–‡æœ¬å†…å®¹çš„æ™ºèƒ½é“¾æ¥æå–
            self.extract_links_from_text(response, current_url, task).await
        }
    }

    /// è§£æå•ä¸ªå†…å®¹åŒºåŸŸ
    fn parse_content_region(&self, region_data: &Value, default_type: RegionType) -> Option<ContentRegion> {
        let content = region_data.get("content")?.as_str()?.to_string();
        let relevance_score = region_data.get("relevance_score")
            .and_then(|v| v.as_f64())
            .unwrap_or(0.5) as f32;
        let selector_path = region_data.get("selector_path")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let region_type = region_data.get("region_type")
            .and_then(|v| v.as_str())
            .and_then(|s| self.parse_region_type(s))
            .unwrap_or(default_type);

        let extracted_links = region_data.get("extracted_links")
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|link_data| self.parse_extracted_link(link_data, "", &CrawlTask {
                        task_id: String::new(),
                        target_description: String::new(),
                        start_url: String::new(),
                        library_name: String::new(),
                        programming_language: String::new(),
                        expected_content_types: Vec::new(),
                        max_depth: 0,
                        max_pages: 0,
                        created_at: chrono::Utc::now(),
                    }))
                    .collect()
            })
            .unwrap_or_default();

        Some(ContentRegion {
            region_type,
            content,
            relevance_score,
            selector_path,
            extracted_links,
        })
    }

    /// è§£æå•ä¸ªæå–çš„é“¾æ¥
    fn parse_extracted_link(&self, link_data: &Value, current_url: &str, task: &CrawlTask) -> Option<ExtractedLink> {
        let url = link_data.get("url")?.as_str()?.to_string();
        let text = link_data.get("text")?.as_str()?.to_string();
        
        let link_type = link_data.get("link_type")
            .and_then(|v| v.as_str())
            .and_then(|s| self.parse_link_type(s))
            .unwrap_or(LinkType::Related);

        let relevance_score = link_data.get("relevance_score")
            .and_then(|v| v.as_f64())
            .unwrap_or(0.5) as f32;

        let priority = link_data.get("priority")
            .and_then(|v| v.as_u64())
            .unwrap_or(3) as u8;

        Some(ExtractedLink {
            url,
            text,
            link_type,
            relevance_score,
            priority,
        })
    }

    /// è§£æåŒºåŸŸç±»å‹
    fn parse_region_type(&self, type_str: &str) -> Option<RegionType> {
        match type_str.to_lowercase().as_str() {
            "main_content" => Some(RegionType::MainContent),
            "navigation" => Some(RegionType::Navigation),
            "sidebar" => Some(RegionType::Sidebar),
            "code_example" => Some(RegionType::CodeExample),
            "api_documentation" => Some(RegionType::ApiDocumentation),
            "tutorial" => Some(RegionType::Tutorial),
            "related_links" => Some(RegionType::RelatedLinks),
            "table_of_contents" => Some(RegionType::TableOfContents),
            _ => None,
        }
    }

    /// è§£æé“¾æ¥ç±»å‹
    fn parse_link_type(&self, type_str: &str) -> Option<LinkType> {
        match type_str.to_lowercase().as_str() {
            "documentation" => Some(LinkType::Documentation),
            "tutorial" => Some(LinkType::Tutorial),
            "api_reference" => Some(LinkType::ApiReference),
            "example" => Some(LinkType::Example),
            "download" => Some(LinkType::Download),
            "external_reference" => Some(LinkType::ExternalReference),
            "navigation" => Some(LinkType::Navigation),
            "related" => Some(LinkType::Related),
            _ => None,
        }
    }

    /// ä»æ–‡æœ¬å†…å®¹è§£æå†…å®¹åŒºåŸŸï¼ˆå¤‡ç”¨æ–¹æ³•ï¼‰
    async fn parse_content_regions_from_text(&self, text: &str, task: &CrawlTask) -> Result<ContentRegionAnalysis> {
        // åŸºäºå…³é”®è¯å’Œæ¨¡å¼åŒ¹é…çš„æ™ºèƒ½è§£æ
        let mut main_content_regions = Vec::new();
        
        // æ£€æµ‹ä¸»è¦å†…å®¹
        if text.to_lowercase().contains(&task.library_name.to_lowercase()) {
            main_content_regions.push(ContentRegion {
                region_type: RegionType::MainContent,
                content: text.to_string(),
                relevance_score: 0.8,
                selector_path: Some("main".to_string()),
                extracted_links: Vec::new(),
            });
        }

        Ok(ContentRegionAnalysis {
            main_content_regions,
            navigation_regions: Vec::new(),
            sidebar_regions: Vec::new(),
            related_links_regions: Vec::new(),
            code_regions: Vec::new(),
        })
    }

    /// ä»æ–‡æœ¬å†…å®¹æå–é“¾æ¥ï¼ˆå¤‡ç”¨æ–¹æ³•ï¼‰
    async fn extract_links_from_text(&self, text: &str, current_url: &str, task: &CrawlTask) -> Result<Vec<ExtractedLink>> {
        // åŸºäºæ­£åˆ™è¡¨è¾¾å¼å’Œå…³é”®è¯åŒ¹é…çš„é“¾æ¥æå–
        let mut links = Vec::new();
        
        // ç®€å•çš„URLåŒ¹é…æ¨¡å¼
        let url_pattern = regex::Regex::new(r"https?://[^\s<>\"]+").unwrap();
        
        for url_match in url_pattern.find_iter(text) {
            let url = url_match.as_str().to_string();
            let relevance_score = if url.to_lowercase().contains(&task.library_name.to_lowercase()) {
                0.9
            } else {
                0.3
            };

            links.push(ExtractedLink {
                url: url.clone(),
                text: url,
                link_type: LinkType::Related,
                relevance_score,
                priority: 3,
            });
        }

        Ok(links)
    }

    /// è§£æå†…å®¹ç±»å‹
    fn parse_content_type(&self, type_str: &str) -> Option<ContentType> {
        match type_str.to_lowercase().as_str() {
            "documentation" => Some(ContentType::Documentation),
            "tutorial" => Some(ContentType::Tutorial),
            "api_reference" => Some(ContentType::ApiReference),
            "examples" => Some(ContentType::Examples),
            "getting_started" => Some(ContentType::GettingStarted),
            "installation" => Some(ContentType::Installation),
            "configuration" => Some(ContentType::Configuration),
            "troubleshooting" => Some(ContentType::Troubleshooting),
            "changelog" => Some(ContentType::Changelog),
            "community" => Some(ContentType::Community),
            _ => None,
        }
    }

    /// è§£ææ¨èè¡ŒåŠ¨
    fn parse_recommended_action(&self, action_str: &str) -> Option<RecommendedAction> {
        match action_str.to_lowercase().as_str() {
            "extract_content" => Some(RecommendedAction::ExtractContent),
            "follow_links" => Some(RecommendedAction::FollowLinks),
            "skip_page" => Some(RecommendedAction::SkipPage),
            "prioritize_highly" => Some(RecommendedAction::PrioritizeHighly),
            "analyze_deeper" => Some(RecommendedAction::AnalyzeDeeper),
            _ => None,
        }
    }

    /// è·å–ç¼“å­˜çš„ç›¸å…³æ€§åˆ†æ
    async fn get_cached_relevance(&self, cache_key: &str) -> Option<PageRelevanceAnalysis> {
        let cache = self.analysis_cache.read().await;
        cache.get(cache_key).map(|cached| cached.relevance_analysis.clone())
    }

    /// ç¼“å­˜ç›¸å…³æ€§åˆ†æç»“æœ
    async fn cache_relevance_analysis(&self, cache_key: &str, analysis: &PageRelevanceAnalysis) {
        let mut cache = self.analysis_cache.write().await;
        cache.insert(cache_key.to_string(), CachedAnalysis {
            relevance_analysis: analysis.clone(),
            content_regions: ContentRegionAnalysis {
                main_content_regions: Vec::new(),
                navigation_regions: Vec::new(),
                sidebar_regions: Vec::new(),
                related_links_regions: Vec::new(),
                code_regions: Vec::new(),
            },
            timestamp: Utc::now(),
        });
    }

    /// Clear cache
    pub async fn clear_cache(&self) {
        let mut cache = self.analysis_cache.write().await;
        cache.clear();
    }

    /// Get cache stats
    pub async fn get_cache_stats(&self) -> usize {
        let cache = self.analysis_cache.read().await;
        cache.len()
    }
}
