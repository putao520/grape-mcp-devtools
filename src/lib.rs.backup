//! # Grape Vector Database
//!
//! 一个高性能的嵌入式向量数据库，专为AI应用和语义搜索设计。
//!
//! ## 特性
//!
//! - **高性能**: 基于HNSW算法的近似最近邻搜索
//! - **嵌入式**: 无需外部服务，直接集成到应用中
//! - **智能缓存**: 多层缓存策略，减少API调用70%
//! - **混合搜索**: 结合向量相似度和文本匹配
//! - **持久化**: 支持磁盘存储和数据恢复
//! - **批量操作**: 高效的批量插入和查询
//! - **去重**: 智能的重复文档检测
//!
//! ## 快速开始
//!
//! ```rust
//! use grape_vector_db::*;
//!
//! #[tokio::main]
//! async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     // 创建向量数据库实例
//!     let mut db = VectorDatabase::new("./data").await?;
//!     
//!     // 添加文档
//!     let doc = Document {
//!         id: "doc1".to_string(),
//!         content: "Rust是一种系统编程语言".to_string(),
//!         title: Some("Rust介绍".to_string()),
//!         language: Some("zh".to_string()),
//!         ..Default::default()
//!     };
//!     
//!     db.add_document(doc).await?;
//!     
//!     // 搜索相似文档
//!     let results = db.search("编程语言", 10).await?;
//!     
//!     Ok(())
//! }
//! ```

pub mod types;
pub mod config;
pub mod storage;
pub mod embeddings;
pub mod query;
pub mod index;
pub mod metrics;
pub mod errors;

// 主要组件的重新导出
pub use types::{Document, DocumentRecord, SearchResult, VectorPoint, DatabaseStats};
pub use config::VectorDbConfig;
pub use storage::{VectorStore, BasicVectorStore};
pub use embeddings::{EmbeddingProvider, MockEmbeddingProvider, create_provider};
pub use query::QueryEngine;
pub use index::HnswIndex;
pub use metrics::{PerformanceMetrics, MetricsCollector};
pub use errors::{VectorDbError, Result};

use std::path::Path;

/// 主要的向量数据库接口
pub struct VectorDatabase {
    store: Box<dyn VectorStore>,
    embedding_provider: Box<dyn EmbeddingProvider>,
    query_engine: QueryEngine,
    config: VectorDbConfig,
}

impl VectorDatabase {
    /// 创建新的向量数据库实例
    pub async fn new<P: AsRef<Path>>(data_dir: P) -> Result<Self> {
        let config = VectorDbConfig::default();
        Self::with_config(data_dir, config).await
    }

    /// 使用自定义配置创建向量数据库实例
    pub async fn with_config<P: AsRef<Path>>(data_dir: P, config: VectorDbConfig) -> Result<Self> {
        let store = Box::new(BasicVectorStore::new(data_dir.as_ref().to_path_buf(), &config).await?);
        let embedding_provider = create_provider(&config)?;
        let query_engine = QueryEngine::new(&config);

        Ok(Self {
            store,
            embedding_provider,
            query_engine,
            config,
        })
    }

    /// 添加单个文档
    pub async fn add_document(&mut self, document: Document) -> Result<String> {
        let embedding = self.embedding_provider.generate_embedding(&document.content).await?;
        
        let record = DocumentRecord {
            id: document.id.clone(),
            content: document.content,
            title: document.title.unwrap_or_else(|| "未标题".to_string()),
            language: document.language.unwrap_or_else(|| "unknown".to_string()),
            package_name: document.package_name.unwrap_or_else(|| "unknown".to_string()),
            version: document.version.unwrap_or_else(|| "latest".to_string()),
            doc_type: document.doc_type.unwrap_or_else(|| "general".to_string()),
            metadata: document.metadata,
            embedding,
        };

        self.store.add_document(record).await?;
        Ok(document.id)
    }

    /// 批量添加文档
    pub async fn add_documents(&mut self, documents: Vec<Document>) -> Result<Vec<String>> {
        let mut ids = Vec::new();
        for document in documents {
            let id = self.add_document(document).await?;
            ids.push(id);
        }
        Ok(ids)
    }

    /// 搜索相似文档
    pub async fn search(&self, query: &str, limit: usize) -> Result<Vec<SearchResult>> {
        let query_vector = self.embedding_provider.generate_embedding(query).await?;
        self.query_engine.search(self.store.as_ref(), &query_vector, query, limit).await
    }

    /// 获取数据库统计信息
    pub fn stats(&self) -> DatabaseStats {
        self.store.stats()
    }

    /// 保存数据到磁盘
    pub async fn save(&self) -> Result<()> {
        self.store.save().await
    }

    /// 从磁盘加载数据
    pub async fn load(&mut self) -> Result<()> {
        self.store.load().await
    }
} 